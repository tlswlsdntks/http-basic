-- TCP/UDP --

TCP
: 전송 제어 프로토콜

특징)
연결지향(TCP 3 way handshake, 가상연결) -> SYN(접속 요청), ACK(요청 수락)
 1.SYN,
 2.SYN + ACK,
 3.ACK (3.ACK와 함께 데이터 전송도 가능)
데이터 전달 보증: 데이터 전송 -> 데이터 전송 잘받음(답변)
순서보장: 패킷1, 패킷2, 패킷3 -> 패킷1, 패킷3(X), 패킷2 -> 패킷2부터 다시 보내라고 요청
신뢰할 수 있는 프로토콜
* 현재 대부분 TCP 사용

UDP
:사용자 데이터 프로토콜

특징)
하얀 도화지(기능이 거의 없음)
연결지향(TCP 3 way handshake, 가상연결) -> X
데이터 전달 보증 -> X
순서보장 -> X
데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠름

정리) 
IP와 거의 같고, 
PORT 및 체크섬(네트워크를 통해서 전송된 데이터의 값이 변경되었는지(무결성)를 검사하는 값) 정도만 추가
어플리케이션에서 추가 작업이 필요


-- PORT --
PORT
: 같은 IP 내부에서 프로세스 구분

TCP/IP패킷)
출발지IP, PORT,
목적지IP, PORT,
전송데이터

PORT 구분)
0 ~ 65535: 할당 가능
0 ~ 1023: 잘 알려진 포트, 사용하지 않는 것 이 좋음
FTP:    20, 21
TELNET: 23
HTTP:   80
HTTPS:  443


-- DNS --
DNS
: 도메인 네임 시스템
  전화번호부, 도메인 명을 IP주소로 변환

사용이유)
IP는 기억하기 어렵다
IP는 변경될 수 있다(과거IP -> 신규IP)

DNS사용)
DNS 서버
도메인명   | IP
google.com | 210.210.210.3

인터넷 네트워크 정리)
인터넷통신
IP
TCP/UDP
PORT
DNS


-- URI와 웹브라우저 요청흐름 --
URI
: Uniform Resource Identifier,
  URL과 URN 포함관계,
  URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류할 수 있다

단어 뜻)
Uniform:    리소스 식별하는 통일된 방식
Resource:   자원, URI로 식별할 수 있는 모든 것(제한 없음)
Identifier: 다른 항목과 구분하는데 필요한 정보
URL:        Uniform Resource Locator(리소스가 있는 위치를 지정)
URN:        Uniform Resource Name(리소스에 이름을 부여)

URL/URN)
위치는 변할 수 있지만, 이름은 변하지 않는다
urn:isbn:8960777331 (어떤 책의 isbn URN)
URN 이름만으로 실제 리소스를 찾을 수 있는 방법이 보편화 되지않음
* URI를 URL과 같은 의미로 사용


URL 전체문법)
scheme://[userinfo@]host[:port][/path][?query][#fragment]
https://www.google.com/search?q=hello&hl=ko
프로토콜   : https
호스트명   : www.google.com
포트번호   : 443
패스       : /search
쿼리 스트링: ?q=hello&hl=ko

scheme)
-> https
주로 프로토콜을 사용
프로토콜: 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
 예) http(port: 80), https(port: 443), ftp, ...
포트는 생략이 가능하다
https는 http에 보안이 추가된 것(Http Secure)

userinfo)
-> X
URL에 사용자정보를 포함해서 인증
* 거의 사용하지 않는다

host)
-> www.google.com
호스트명
IP주소 또는 도메인명을 직접 사용 가능하다

port)
-> 443
포트(접속포트)
일반적으로 생략, http(80), https(443)

path)
-> /search, 
   /home/file1.jsp, /members, /members/100, /items/iphone12
리소스 경로, 계층적 구조

query)
-> ?q=hello&hl=ko
key = value 형태
?로 시작, &로 추가 가능, ?keyA=valueA&keyB=valueB
query parameter, query string 등으로 불림
웹 서버에 제공하는 파라미터, 문자형태로 전송 (숫자->문자)

fragment)
https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started.introducing-spring-boot
-> #getting-started.introducing-spring-boot
html 내부 북마크 등에 사용
서버에 전송하는 정보는 아님


웹브라우저 요청흐름
요청흐름)
https://www.google.com/search?q=hello&hl=ko 검색 -> DNS 조회(www.google.com) -> https(443) 포트생략
 -> http 요청 메세지 전달(GET /search?q=hello&hl=ko HTTP/1.1 Host: www.google.com)

HTTP 메세지 전송)
웹 브라우저가 HTTP 메세지 생성 -> 소켓 라이브러리를 통해 전달(TCP/IP 연결, HTTP 메세지 포함)
-> TCP/IP 패킷 생성, HTTP 메세지 포함 -> LAN 카드 -> 인터넷 -> 서버

패킷생성)
출발지IP, PORT,
목적지IP, PORT,
http 요청 메세지(
    GET /search?q=hello&hl=ko 
    HTTP/1.1 
        Host: www.google.com
)

전처리)
http 응답 메세지(
    HTTP/1.1 200 OK
    Content-Type: text/html;charset=UTF-8
    Content-Length: 3423
    <html>
    <body>...</body>
    </html>
),
웹 브라우저 HTML 렌더링


-- HTTP --
HTTP
: HyperText Transfer Protocol

모든 것이 HTTP)
HTTP 메세지에 모든 것을 전송
 - HTML, TEXT
 - IMAGE, 음성, 영상, 파일
 - JSON, XML(API)
 - 거의 모든 형태의 데이터 전송 가능 
 - 서버 간에 데이터를 주고 받을 때도 대부분 HTTP 사용
 - 지금은 HTTP 시대!

HTTP 역사)
...
HTTP/1.1 (1997년): 가장 많이 사용, 우리에게 가장 중요한 버전
 - RFC2068(1997) -> RFC2616(1999) -> RFC7230~7235(2014)
HTTP/2   (2015년): 성능개선
HTTP/3   (진행중): TCP 대신 UDP 사용, 성능개선 

기반 프로토콜)
TCP: HTTP/1.1, HTTP/2
UDP: HTTP/3
현재 HTTP/1.1을 주로 사용, HTTP/2, HTTP/3 도 점점 증가하는 추세


-- HTTP 특징 --
클라이언트 서버 구조)
Request <---> Response 구조
클라이언트는 서버에 요청으 보내고, 응답을 대기
서버는 요청에 따른 결과를 만들어서 응답
클라이언트와 서버는 독립적인 기능을 유지 -> 클라이언트는 비즈니스로직 포함X


무상태 프로토콜)
: 스테이리스(Stateless)
서버가 클라이언트의 상태를 보존하지않는다
장점: 서버 확장성을 높임(스케일 아웃)
단점: 클라이언트가 추가 데이터 전송

예시) 상태유지 -> 무상태
고객: 이 노트북 얼마인가요?
점원A: 100만원입니다

고객: 2개 구매하겠습니다 -> 노트북 2개 구매하겠습니다
점원A: ? 무엇을 2개 구매하시겠어요? -> 노트북 2개는 200만원입니다, 신용카드, 현금 중 어떤걸로 구매하시겠어요?

고객: 신용카드로 구매하겠습니다 -> 노트북 2개를 신용카드로 구매하겠습니다
점원A: ? 무슨 제품을 몇 개, 신용카드로 구매하시겠어요? -> 200만원 결제되었습니다

상태유지(Statelful) 과 무상태(Stateless) 차이)
상태유지(Statelful): 중간에 다른 점원으로 바뀌면 안된다
무상태(Stateless): 중간에 다른 점원으로 바뀌어도 된다
* 무상태는 응답서버를 쉽게 바꿀 수 있다 -> 무한한 서버 증설 가능(스케일아웃: 수평 확장 유리)

실무한계)
모든 것을 무상태로 설계 할 수 있는 경우도 있고, 없는 경우도 있다
무상태(Stateless): 로그인이 필요없는 단순한 서비스 화면
상태유지(Statelful): 로그인
* 로그인한 사용자의 경우, 일반적으로 브라우저 쿠키와 서버 세션 등을 이용하여 상태를 유지시킨다
* 상태유지는 최소한으로만 설계.


비연결성)
: Connectionless

특징)
HTTP는 기본이 연결을 유지하는 모델
일반적으로 초 단위 이하의 빠른 속도로 응답
1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적음
 예) 웹 브라우저에게 계속적으로 연속해서 검색버튼을 누르진않는다
서버 자원을 매우 효율적으로 사용할 수 있음

한계와 극복)
TCP/IP 연결을 새로 맺어야함 -> 3 way handshake(SYN <-> ACK) 시간 추가
웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라, 자바스크립트, CSS, IMG 등 수 많은 자원이 함께 다운로드
* 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
HTTP/2, HTTP/3 에서 더 많은 최적화

무상태(Stateless)를 기억하자)
서버 개발자들이 어려워하는 업무 -> 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
예) 선착순 이벤트, 명절 KTX 예매, 학과 수업등록


HTTP 메세지)
: 거의 모든 형태의 데이터 전송 가능

예시)
HTTP 요청 메세지                            HTTP 응답 메세지                            HTTP 메세지 구조
------------------------------------------------------------------------------------------------------------------
GET /search?q=hello&hl=ko HTTP/1.1          HTTP/1.1 200 OK                             start-line 시작라인
------------------------------------------------------------------------------------------------------------------
Host: www.google.com                        Content-Type: text/html;charset=UTF-8       header 헤더
                                            Content-Length: 3423
------------------------------------------------------------------------------------------------------------------
                                                                                        empty line 공백라인 (CRLF)
------------------------------------------------------------------------------------------------------------------
* 요청 메세지도 body 본문을 가질 수 있음    <html>                                      message body
                                            <body>...</body>
                                            </html>
------------------------------------------------------------------------------------------------------------------

HTTP 요청 메세지)
* SP(공백), CRLF(엔터)
start-line(request-line)
    -> method (SP) request-target (SP) http-version (CRLF)
method: HTTP 메소드(GET) -> 조회
    종류: GET(조회), POST(요청 내역 처리), PUT, DELETE
요청대상: /search?q=hello&hl=ko
    절대경로 = "/"로 시작하는 경로
HTTP Version: HTTP/1.1


HTTP 응답 메세지)
start-line(status-line)
    -> http-version (SP) status-line (SP) reason-phrase (CRLF)
HTTP Version: HTTP/1.1
HTTP 상태코드: 요청 성공/실패를 나타냄
    200: 성공,
    400: 클라이언트 요청 오류,
    500: 서버 내부 오류,
이유문구: 사람이 이해할 수 있는 짧은 상태 설명글 -> OK

header-field
    -> field-name ":" OWS field-value OWS (OWS:띄어쓰기 허용)
    * field-name: 대소문자 구문 없음
    Host: www.google.com    Content-Type: text/html;charset=UTF-8
                            Content-Length: 3423
HTTP 전송에 필요한 모든 부가정보
예) 메세지 바디의 내용, 메세지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보,
    서버 어플리케이션 정보, 캐쉬 관리 정보
표준 헤더가 너무 많다
필요시, 임의의 헤더 추가 기능 -> 예) helloworld: hi 

message body
    -> <html><body></body></html>
실제 전송할 데이터
HTML 문서, 이미지, 영상, JSON 등등 -> byte로 표현할 수 있는 모든 데이터 전송 가능

단순함 확장 가능)
HTTP는 단순하다 -> 스펙 읽어봐도 됨..
HTTP 메세지도 매우 단순
크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술