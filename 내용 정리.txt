
-- HTTP 특징 --
클라이언트 서버 구조)
Request <---> Response 구조
클라이언트는 서버에 요청으 보내고, 응답을 대기
서버는 요청에 따른 결과를 만들어서 응답
클라이언트와 서버는 독립적인 기능을 유지 -> 클라이언트는 비즈니스로직 포함X


무상태 프로토콜)
: 스테이리스(Stateless)
서버가 클라이언트의 상태를 보존하지않는다
장점: 서버 확장성을 높임(스케일 아웃)
단점: 클라이언트가 추가 데이터 전송

예시) 상태유지 -> 무상태
고객: 이 노트북 얼마인가요?
점원A: 100만원입니다

고객: 2개 구매하겠습니다 -> 노트북 2개 구매하겠습니다
점원A: ? 무엇을 2개 구매하시겠어요? -> 노트북 2개는 200만원입니다, 신용카드, 현금 중 어떤걸로 구매하시겠어요?

고객: 신용카드로 구매하겠습니다 -> 노트북 2개를 신용카드로 구매하겠습니다
점원A: ? 무슨 제품을 몇 개, 신용카드로 구매하시겠어요? -> 200만원 결제되었습니다

상태유지(Statelful) 과 무상태(Stateless) 차이)
상태유지(Statelful): 중간에 다른 점원으로 바뀌면 안된다
무상태(Stateless): 중간에 다른 점원으로 바뀌어도 된다
* 무상태는 응답서버를 쉽게 바꿀 수 있다 -> 무한한 서버 증설 가능(스케일아웃: 수평 확장 유리)

실무한계)
모든 것을 무상태로 설계 할 수 있는 경우도 있고, 없는 경우도 있다
무상태(Stateless): 로그인이 필요없는 단순한 서비스 화면
상태유지(Statelful): 로그인
* 로그인한 사용자의 경우, 일반적으로 브라우저 쿠키와 서버 세션 등을 이용하여 상태를 유지시킨다
* 상태유지는 최소한으로만 설계.


비연결성)
: Connectionless

특징)
HTTP는 기본이 연결을 유지하는 모델
일반적으로 초 단위 이하의 빠른 속도로 응답
1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적음
 예) 웹 브라우저에게 계속적으로 연속해서 검색버튼을 누르진않는다
서버 자원을 매우 효율적으로 사용할 수 있음

한계와 극복)
TCP/IP 연결을 새로 맺어야함 -> 3 way handshake(SYN <-> ACK) 시간 추가
웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라, 자바스크립트, CSS, IMG 등 수 많은 자원이 함께 다운로드
* 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
HTTP/2, HTTP/3 에서 더 많은 최적화

무상태(Stateless)를 기억하자)
서버 개발자들이 어려워하는 업무 -> 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽
예) 선착순 이벤트, 명절 KTX 예매, 학과 수업등록


HTTP 메세지)
: 거의 모든 형태의 데이터 전송 가능

예시)
HTTP 요청 메세지                            HTTP 응답 메세지                            HTTP 메세지 구조
------------------------------------------------------------------------------------------------------------------
GET /search?q=hello&hl=ko HTTP/1.1          HTTP/1.1 200 OK                             start-line 시작라인
------------------------------------------------------------------------------------------------------------------
Host: www.google.com                        Content-Type: text/html;charset=UTF-8       header 헤더
                                            Content-Length: 3423
------------------------------------------------------------------------------------------------------------------
                                                                                        empty line 공백라인 (CRLF)
------------------------------------------------------------------------------------------------------------------
* 요청 메세지도 body 본문을 가질 수 있음    <html>                                      message body
                                            <body>...</body>
                                            </html>
------------------------------------------------------------------------------------------------------------------

HTTP 요청 메세지)
* SP(공백), CRLF(엔터)
start-line(request-line)
    -> method (SP) request-target (SP) http-version (CRLF)
method: HTTP 메소드(GET) -> 조회
    종류: GET(조회), POST(요청 내역 처리), PUT, DELETE
요청대상: /search?q=hello&hl=ko
    절대경로 = "/"로 시작하는 경로
HTTP Version: HTTP/1.1


HTTP 응답 메세지)
start-line(status-line)
    -> http-version (SP) status-line (SP) reason-phrase (CRLF)
HTTP Version: HTTP/1.1
HTTP 상태코드: 요청 성공/실패를 나타냄
    200: 성공,
    400: 클라이언트 요청 오류,
    500: 서버 내부 오류,
이유문구: 사람이 이해할 수 있는 짧은 상태 설명글 -> OK

header-field
    -> field-name ":" OWS field-value OWS (OWS:띄어쓰기 허용)
    * field-name: 대소문자 구문 없음
    Host: www.google.com    Content-Type: text/html;charset=UTF-8
                            Content-Length: 3423
HTTP 전송에 필요한 모든 부가정보
예) 메세지 바디의 내용, 메세지 바디의 크기, 압축, 인증, 요청 클라이언트(브라우저) 정보,
    서버 어플리케이션 정보, 캐쉬 관리 정보
표준 헤더가 너무 많다
필요시, 임의의 헤더 추가 기능 -> 예) helloworld: hi 

message body
    -> <html><body></body></html>
실제 전송할 데이터
HTML 문서, 이미지, 영상, JSON 등등 -> byte로 표현할 수 있는 모든 데이터 전송 가능

단순함 확장 가능)
HTTP는 단순하다 -> 스펙 읽어봐도 됨..
HTTP 메세지도 매우 단순
크게 성공하는 표준 기술은 단순하지만 확장 가능한 기술