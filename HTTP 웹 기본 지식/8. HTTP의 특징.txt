클라이언트 서버 구조)
- Request <-> Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버는 요청에 따른 결과를 만들어서 응답
- 클라이언트와 서버는 독립적인 기능을 유지 -> 클라이언트는 비즈니스 로직을 포함하지 않는다

무상태 프로토콜)
: 스테이리스(Stateless)
- 서버가 클라이언트의 상태를 보존하지않는다
- 장점: 서버 확장성을 높임(스케일 아웃: 수평 확장 유리)
- 단점: 클라이언트가 추가 데이터를 전송해야한다

무상태 프로토콜의 예시) 
: 상태유지 -> 무상태
고객: 이 노트북 얼마인가요?
점원A: 100만원입니다

고객: 2개 구매하겠습니다 -> 노트북 2개 구매하겠습니다
점원A: ? 무엇을 2개 구매하시겠어요? -> 노트북 2개는 200만원입니다, 신용카드, 현금 중 어떤걸로 구매하시겠어요?

고객: 신용카드로 구매하겠습니다 -> 노트북 2개를 신용카드로 구매하겠습니다
점원A: ? 무슨 제품을 몇 개, 신용카드로 구매하시겠어요? -> 200만원 결제되었습니다

상태유지(Statelful) 과 무상태(Stateless) 차이)
상태유지(Statelful): 중간에 다른 점원으로 바뀌면 안된다
무상태(Stateless): 중간에 다른 점원으로 바뀌어도 된다
 * 무상태는 응답서버를 쉽게 바꿀 수 있다 -> 무한한 서버 증설 가능(스케일아웃)

실무한계)
: 모든 것을 무상태로 설계할 수 있는 경우도 있고, 없는 경우도 있다
- 무상태(Stateless): 로그인이 필요없는 단순한 서비스 화면
- 상태유지(Statelful): 로그인
   * 로그인한 사용자의 경우, 일반적으로 브라우저 쿠키와 서버 세션 등을 이용하여 상태를 유지시킨다
   * 상태유지는 최소한으로만 설계한다

비연결성)
: Connectionless
- HTTP는 기본적으로, 연결을 유지하는 모델이다
- 일반적으로 초 단위 이하의 빠른 속도로 응답이 가능하다
- 1시간 동안 수천명이 서비스를 사용해도, 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 적다
   예) 웹 브라우저에서 계속 연속적으로 검색버튼을 누르진 않는다

비연결성으로 인한 한계와 극복)
- TCP/IP 연결을 새로 맺어야함 -> 3 way handshake(SYN <-> ACK) 시간이 추가적으로 필요하다
- 웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라, 자바스크립트, CSS, IMG 등 수 많은 자원이 함께 다운로드된다
  * 지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
    HTTP/2, HTTP/3 에서 더 많은 최적화

무상태(Stateless)의 강조)
- 서버 개발자들이 어려워하는 업무 -> 정말 같은 시간에 딱 맞추어 발생하는 대용량 트래픽 이슈이다
   예시) 선착순 이벤트, 명절 KTX 예매, 학과 수업등록